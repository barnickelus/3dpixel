<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Genesis Evolution — Star-Frenzy (3D Dragon Head)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <style>
    html, body {
      margin: 0; height: 100%;
      background: #060616; overflow: hidden;
      font-family: "Inter", Arial, sans-serif;
    }
    canvas#game {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      display: block; touch-action: none;
      background: #000;
    }
    /* head wrapper & its canvas */
    #dragonHead {
      position: absolute;
      pointer-events: none;
      z-index: 3;
    }
    #headCanvas {
      display: block;
    }
    /* HUD & controls */
    #hud, #compass, #effBar, #pauseBtn, #radarWrap, #zoomSlider {
      position: fixed; z-index: 2;
    }
    #hud {
      top:14px; left:18px;
      color:#fff; font-size:15px;
      text-shadow:0 0 4px rgba(255,255,255,.3);
    }
    #compass {
      top:60px; left:18px;
      color:#aaa; font-size:12px;
      line-height:12px; letter-spacing:1px;
      text-shadow:0 0 2px #000;
    }
    #effBar {
      bottom:14px; left:18px;
      width:220px; height:18px;
      border-radius:9px;
      background:rgba(255,255,255,.12);
    }
    #effFill {
      width:100%; height:100%;
      border-radius:9px;
      background:#00e4b8;
    }
    #pauseBtn {
      top:14px; right:18px;
      font-size:22px; color:#fff;
      cursor:pointer; user-select:none;
    }
    #radarWrap {
      top:48px; right:18px;
      width:70px; height:70px;
      display:none;
    }
    #radar {
      width:70px; height:70px;
      border:1px solid #555;
      border-radius:4px;
      background:rgba(0,0,0,.4);
    }
    #zoomSlider {
      top:130px; right:18px;
      width:70px; transform:rotate(-90deg);
    }
  </style>
</head>
<body>
  <!-- 1) Game canvas -->
  <canvas id="game"></canvas>

  <!-- 2) Dragon head wrapper & canvas -->
  <div id="dragonHead">
    <canvas id="headCanvas"></canvas>
  </div>

  <!-- 3) HUD -->
  <div id="hud">
    Mass: <span id="mass">10</span>&nbsp;
    Score: <span id="score">0</span>&nbsp;
    <span id="level">1</span>
  </div>
  <div id="compass">N<br>E&nbsp;&nbsp;W<br>&nbsp;S</div>
  <div id="effBar"><div id="effFill"></div></div>
  <div id="pauseBtn">⏸︎</div>
  <div id="radarWrap">
    <canvas id="radar" width="70" height="70"></canvas>
  </div>
  <input id="zoomSlider" type="range" min="0.5" max="2" step="0.01" value="1">

  <!-- 4) Audio -->
  <audio id="backgroundMusic" src="background-music.mp3" loop preload="auto"></audio>
  <audio id="eatSnd"         src="eat.mp3"    preload="auto"></audio>
  <audio id="hurtSnd"        src="hurt.mp3"   preload="auto"></audio>
  <audio id="frenzySnd"      src="frenzy.mp3" preload="auto"></audio>

  <!-- 5) Three.js + GLTFLoader module to render your .glb head -->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/loaders/GLTFLoader.js';

    const TILE = 48, SCALE = 4;
    const headCanvas = document.getElementById('headCanvas');

    // Renderer
    const renderer = new THREE.WebGLRenderer({
      canvas: headCanvas,
      alpha: true,
      antialias: true
    });
    renderer.setSize(TILE * SCALE, TILE * SCALE);

    // Scene & camera
    const scene  = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(40, 1, 0.1, 100);
    camera.position.set(0, 0, 5);

    // Light
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
    dirLight.position.set(1, 2, 3);
    scene.add(dirLight);

    // Load GLB
    let headMesh = null;
    new GLTFLoader().load(
      'dragon-head.glb',   // ← host your exported model here
      gltf => {
        headMesh = gltf.scene;
        headMesh.rotation.order = 'YXZ';
        scene.add(headMesh);
      },
      undefined,
      err => console.error('GLTF load error:', err)
    );

    // Expose a render function
    window.renderHead = (yawRad, pitchRad) => {
      if (!headMesh) return;
      headMesh.rotation.y = yawRad;
      headMesh.rotation.x = pitchRad;
      renderer.render(scene, camera);
    };
  </script>

  <!-- 6) Full game logic, unchanged except updateHead -->
  <script>
    // Canvas & HUD refs
    const canvas = document.getElementById('game'),
          ctx    = canvas.getContext('2d',{alpha:false});
    ctx.imageSmoothingEnabled = false;

    let W, H;
    function resize(){
      W = canvas.width  = innerWidth;
      H = canvas.height = innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    const massEl   = document.getElementById('mass'),
          scoreEl  = document.getElementById('score'),
          levelEl  = document.getElementById('level'),
          pauseBtn = document.getElementById('pauseBtn'),
          radarC   = document.getElementById('radar'),
          rctx     = radarC.getContext('2d');

    // Constants
    const MASS_THRESH      = 600,
          TITAN_LEVEL      = 10,
          TITAN_MAX        = 6,
          TITAN_RESPAWN_MS = 20000,
          SPECTRE_MAX      = 3,
          REAPER_MAX       = 3,
          C_RING_DIST      = 1600,
          SPECTRE_SPEED_MS = 6000,
          SPECTRE_SPEED_MULT = 1.25,
          RADAR_PADDING    = 4,
          ZOOM_EASE        = 0.25,
          MASS_SPEED_FACTOR= 0.0012,
          EXTRA_TAIL_PCT   = 0.10,
          MAX_TAIL_DRAW    = 60,
          SAFE_PLAYER_MASS = 70,
          BLINK_MS         = 300;

    // Zoom
    let sliderZoom = 1, zoom = 1;
    document.getElementById('zoomSlider').oninput = e => sliderZoom = parseFloat(e.target.value);

    // Helpers
    const rand = v => Math.random()*v - v/2;
    const dist = (x1,y1,x2,y2) => Math.hypot(x2-x1,y2-y1);
    const lerp = (a,b,t) => a + (b-a)*t;
    const rgb  = h => ({
      r: parseInt(h.slice(1,3),16),
      g: parseInt(h.slice(3,5),16),
      b: parseInt(h.slice(5,7),16)
    });
    const mix  = (a,b,t) => {
      const A = rgb(a), B = rgb(b);
      return `rgb(${Math.round(lerp(A.r,B.r,t))},${Math.round(lerp(A.g,B.g,t))},${Math.round(lerp(A.b,B.b,t))})`;
    };

    // World state
    const food      = [],
          foes      = [],
          titans    = [],
          spectres  = [],
          reapers   = [],
          beacons   = [],
          particles = [];
    let player = {
      x:0,y:0,r:15,mass:10,tail:[],
      baseSpeed:2.5,blink:0,speedBoost:0,heading:0
    },
    target = {x:0,y:0,active:false},
    offset = {x:0,y:0},
    pill   = {x:0,y:0,r:10,active:false,cd:0},
    frenzy = false, F_TIME=0,
    paused = false, radarActive=false,
    titanTimer=0, titanKill=0, spectreKill=0,
    level=1;

    // Star field
    const STARS = 120;
    const stars = Array.from({length:STARS},()=>({
      x: rand(4000), y: rand(4000),
      s: Math.random()*1.5+0.5
    }));

    // Spawners
    const spawnFood = ()=>{ while(food.length<60) food.push({x:rand(1800),y:rand(1800),r:6}); };
    const spawnFoe  = ()=>{ foes.push({
      x:rand(2000), y:rand(2000),
      r:(player.mass>=MASS_THRESH?14:10)+Math.random()*20
    }); };
    const spawnTitan= ()=>{ const a=Math.random()*Math.PI*2, d=700+Math.random()*500;
      titans.push({
        x:player.x+Math.cos(a)*d,
        y:player.y+Math.sin(a)*d,
        r:25+Math.random()*35,
        hop:0
      });
    };
    const spawnSpectre= ()=>{ const a=Math.random()*Math.PI*2, d=600+Math.random()*400;
      spectres.push({
        x:player.x+Math.cos(a)*d,
        y:player.y+Math.sin(a)*d,
        r:22+Math.random()*25,
        dash:0
      });
    };
    const spawnReaper = ()=>{ const a=Math.random()*Math.PI*2, d=800+Math.random()*600;
      reapers.push({
        x:player.x+Math.cos(a)*d,
        y:player.y+Math.sin(a)*d,
        r:38+Math.random()*28,
        charge:0
      });
    };
    const spawnPill = ()=>{ pill={x:rand(1800),y:rand(1800),r:10,active:true,cd:0}; };

    // Init world
    spawnFood();
    for(let i=0;i<12;i++) spawnFoe();
    ['N','S','E','W'].forEach(d=>{
      const P={N:[0,-C_RING_DIST],S:[0,C_RING_DIST],
               E:[C_RING_DIST,0],W:[-C_RING_DIST,0]}[d];
      beacons.push({x:P[0],y:P[1],r:18});
    });

    // Input
    function toWorld(e){
      return {x:(e.clientX-offset.x)/zoom,
              y:(e.clientY-offset.y)/zoom};
    }
    canvas.onpointerdown = e=>{
      if(paused) return;
      const p=toWorld(e);
      target={x:p.x,y:p.y,active:true};
    };
    canvas.onpointermove = e=>{
      if(target.active && !paused){
        const p=toWorld(e);
        target.x=p.x; target.y=p.y;
      }
    };
    canvas.onpointerup = ()=> target.active=false;

    // Pause
    pauseBtn.onclick = ()=>{
      paused=!paused;
      pauseBtn.textContent = paused?'▶︎':'⏸︎';
      const bg = document.getElementById('backgroundMusic');
      if(bg) paused?bg.pause():bg.play().catch(()=>{});
    };

    // Draw helpers
    function onScreen(x,y,r){
      return !(
        x+r < player.x - W/(2*zoom) ||
        x-r > player.x + W/(2*zoom) ||
        y+r < player.y - H/(2*zoom) ||
        y-r > player.y + H/(2*zoom)
      );
    }
    function glow(x,y,r,c,a){
      if(r*zoom<0.8||!onScreen(x,y,r)) return;
      ctx.globalAlpha=a;
      ctx.shadowBlur = 12*zoom;
      ctx.shadowColor= c;
      ctx.fillStyle  = c;
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
      ctx.shadowBlur=0;
      ctx.globalAlpha=1;
    }
    function drawGrid(){
      const step= zoom<=0.8?60:120;
      ctx.lineWidth=1.2;
      for(let z=0;z<6;z++){
        const s   = 1+z*0.15,
              opa = 0.8-0.12*z;
        ctx.strokeStyle = `rgba(34,34,34,${opa})`;
        for(let i=-4;i<=4;i++){
          for(let j=-4;j<=4;j++){
            const x=i*step*s, y=j*step*s;
            if(!onScreen(x,y,step*s*1.4)) continue;
            ctx.beginPath();
            ctx.rect(x,y,step*s,step*s);
            ctx.stroke();
          }
        }
      }
    }
    function burst(x,y,c){
      for(let i=0;i<12;i++){
        particles.push({
          x,y,
          dx:rand(2),
          dy:rand(2),
          r:3,
          ttl:600,
          col:c
        });
      }
    }

    // updateHead uses window.renderHead(...)
    function updateHead(screenX, screenY, yawIdx, pitchIdx, zoom){
      const wrap = document.getElementById('dragonHead');
      const size = TILE * SCALE * zoom;
      wrap.style.width  = size+'px';
      wrap.style.height = size+'px';
      wrap.style.left   = (screenX - size/2)+'px';
      wrap.style.top    = (screenY - size/2)+'px';
      const c = document.getElementById('headCanvas');
      c.style.width  = size+'px';
      c.style.height = size+'px';

      const yawRad   = (yawIdx   / COLS) * 2 * Math.PI;
      const pitchRad = ((pitchIdx / (ROWS-1)) - 0.5) * Math.PI;
      window.renderHead(yawRad, pitchRad);
    }

    // Main loop
    let last = 0;
    function loop(ts){
      if(paused){ last=ts; return requestAnimationFrame(loop); }
      const dt = (ts - last) || 16;
      last = ts;

      // Zoom & move
      zoom = lerp(zoom,
                  Math.min(sliderZoom, Math.max(0.5, H/(player.r*4))),
                  ZOOM_EASE
      );
      const dx   = (target.active?target.x:player.x) - player.x,
            dy   = (target.active?target.y:player.y) - player.y,
            dLen = Math.hypot(dx,dy);
      if(dLen>0.5) player.heading = Math.atan2(dy,dx);
      if(player.speedBoost>0) player.speedBoost = Math.max(0, player.speedBoost - dt);
      const speed = player.baseSpeed
                  * (player.speedBoost>0?SPECTRE_SPEED_MULT:1)
                  * (frenzy?1.3:1)
                  * (1 + player.mass * MASS_SPEED_FACTOR);
      if(dLen>1){
        player.x += dx/dLen * speed;
        player.y += dy/dLen * speed;
      }

      // Mass decay
      player.mass = Math.max(5,
        player.mass - (0.000009*player.r*player.r +
                       (player.mass<150?0.002:0.003)) * dt
      );

      // Recenter
      offset.x = W/2 - player.x * zoom;
      offset.y = H/2 - player.y * zoom;

      // Background (stars+grid)
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle='#060616';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#222';
      for(const s of stars){
        const sx=(s.x - player.x*0.1)*zoom + offset.x,
              sy=(s.y - player.y*0.1)*zoom + offset.y;
        if(sx<0||sx>W||sy<0||sy>H) continue;
        ctx.fillRect(sx,sy,s.s,s.s);
      }
      ctx.setTransform(zoom,0,0,zoom,offset.x,offset.y);
      drawGrid();

      // Food & spawn
      for(let i=food.length-1;i>=0;i--){
        const f=food[i];
        if(dist(player.x,player.y,f.x,f.y)<player.r+f.r){
          player.mass += f.r;
          food.splice(i,1);
          burst(f.x,f.y,'#ff0');
          document.getElementById('eatSnd').play().catch(()=>{});
        }
      }
      spawnFood();

      // Foes
      while(foes.length < (player.mass>=MASS_THRESH?18:12)) spawnFoe();
      foes.forEach((o,i)=>{
        const d=dist(player.x,player.y,o.x,o.y);
        if(player.r>o.r && d<player.r){
          player.mass += o.r*2.5;
          foes.splice(i,1);
          burst(o.x,o.y,'#f00');
          document.getElementById('eatSnd').play().catch(()=>{});
          return;
        }
        if(o.r>player.r && d<o.r){
          if(player.blink<50) player.blink=BLINK_MS;
          player.mass = Math.max(5, player.mass - .04*dt);
          document.getElementById('hurtSnd').play().catch(()=>{});
        }
        const c=1;
        if(o.r<player.r && d<250){
          o.x -= (player.x - o.x)/d * c;
          o.y -= (player.y - o.y)/d * c;
        } else if(o.r>player.r && d<250){
          o.x += (player.x - o.x)/d * c;
          o.y += (player.y - o.y)/d * c;
        }
      });

      // Titans
      if(level>=TITAN_LEVEL){
        while(titans.length<TITAN_MAX) spawnTitan();
        titanTimer += dt;
        if(titanTimer > TITAN_RESPAWN_MS){
          titanTimer = 0; titans.length = 0;
        }
      }
      titans.forEach((o,i)=>{
        const d=dist(player.x,player.y,o.x,o.y);
        if(d>2000){ titans.splice(i,1); spawnTitan(); return; }
        if(player.r>o.r && d<player.r){
          player.mass += o.r*5;
          titans.splice(i,1);
          titanKill++;
          burst(o.x,o.y,'#cc00ff');
          return;
        }
        if(o.r>player.r && d<o.r){
          if(player.blink<50) player.blink=BLINK_MS;
          player.mass = Math.max(5, player.mass - .1*dt);
          document.getElementById('hurtSnd').play().catch(()=>{});
        }
        o.hop -= dt;
        if(o.hop<=0){
          o.hop = 700;
          const hop = o.r>player.r?120:-80;
          o.x += (player.x - o.x)/d * hop;
          o.y += (player.y - o.y)/d * hop;
        }
      });

      // Spectres
      if(titanKill>=10) while(spectres.length<SPECTRE_MAX) spawnSpectre();
      spectres.forEach((s,i)=>{
        s.dash -= dt;
        const d=dist(player.x,player.y,s.x,s.y), ignore=player.mass<SAFE_PLAYER_MASS;
        if(d>2200){ spectres.splice(i,1); spawnSpectre(); return; }
        if(!ignore && d<player.r){
          player.mass += s.r*7;
          player.speedBoost = SPECTRE_SPEED_MS;
          spectres.splice(i,1);
          document.getElementById('eatSnd').play().catch(()=>{});
          spectreKill++;
          if(spectreKill%6===0 && reapers.length<REAPER_MAX) spawnReaper();
          return;
        }
        if(!ignore && d<s.r && s.r>player.r){
          if(player.blink<50) player.blink=BLINK_MS;
          player.mass = Math.max(5, player.mass - .2*dt);
          document.getElementById('hurtSnd').play().catch(()=>{});
        }
        const jump = ignore?-100:(s.r>player.r?160:-100);
        if(s.dash<=0){
          s.dash=400;
          s.x += (player.x - s.x)/d * jump;
          s.y += (player.y - s.y)/d * jump;
        }
      });

      // Reapers
      reapers.forEach((r,i)=>{
        r.charge -= dt;
        const d=dist(player.x,player.y,r.x,r.y), ignore=player.mass<SAFE_PLAYER_MASS;
        if(d>2400){ reapers.splice(i,1); return; }
        if(!ignore && d<player.r){
          player.mass += r.r*10;
          reapers.splice(i,1);
          burst(r.x,r.y,'#ff8800');
          return;
        }
        if(!ignore && d<r.r && r.r>player.r){
          if(player.blink<50) player.blink=BLINK_MS;
          player.mass = Math.max(5, player.mass - .25*dt);
          document.getElementById('hurtSnd').play().catch(()=>{});
        }
        const step = ignore?-100:(r.r>player.r?130:-100);
        if(r.charge<=0){
          r.charge=300;
          r.x += (player.x - r.x)/d * step;
          r.y += (player.y - r.y)/d * step;
        }
      });

      // Pill / Frenzy
      if(pill.active && dist(player.x,player.y,pill.x,pill.y)<player.r+pill.r){
        frenzy=true; F_TIME=10000; pill.active=false;
        document.getElementById('frenzySnd').play().catch(()=>{});
        for(let i=0;i<40;i++){
          const a=Math.random()*Math.PI*2, R=120+Math.random()*120;
          food.push({
            cx:player.x, cy:player.y, ang:a,
            baseR:R, angV:.004+Math.random()*.003,
            x:player.x+Math.cos(a)*R,
            y:player.y+Math.sin(a)*R,
            r:5, frenzy:true, col:'#ff39ff'
          });
        }
      }
      if(frenzy){
        F_TIME -= dt;
        if(F_TIME<=0){ frenzy=false; food.forEach(f=>f.frenzy=false); }
      }
      food.forEach(f=>{
        if(f.frenzy){
          f.ang += f.angV*dt;
          f.x   = f.cx + Math.cos(f.ang)*f.baseR;
          f.y   = f.cy + Math.sin(f.ang)*f.baseR;
        }
      });
      if(!pill.active && !frenzy){
        pill.cd += dt;
        if(pill.cd>25000+Math.random()*10000) spawnPill();
      }

      // Beacons / Radar
      beacons.forEach((b,i)=>{
        if(dist(player.x,player.y,b.x,b.y)<player.r+b.r){
          beacons.length=0; radarActive=true;
          document.getElementById('radarWrap').style.display='block';
        }
      });

      // Size, Tail, Blink
      player.r = 10 + player.mass/15;
      level    = Math.floor(player.mass/100)+1;
      player.tail.unshift({x:player.x,y:player.y});
      while(player.tail.length>Math.ceil(player.mass/3*(1+EXTRA_TAIL_PCT))){
        player.tail.pop();
      }
      if(player.blink>0) player.blink -= dt;

      // Draw Glows
      food.forEach(f=>glow(f.x,f.y,f.r,f.frenzy?f.col:'#ff0',f.frenzy?.8:.65));
      foes.forEach(o=>glow(o.x,o.y,o.r,'#f00',.8));
      titans.forEach(o=>glow(o.x,o.y,o.r,'#cc00ff',.9));
      spectres.forEach(s=>glow(
        s.x,s.y,s.r,
        mix('#ffde59','#ff39ff',(Math.sin((ts+s.x)*.006)+1)/2),
        .9
      ));
      reapers.forEach(r=>glow(
        r.x,r.y,r.r,
        mix('#ff8800','#ff39ff',(Math.sin((ts+r.y)*.004)+1)/2),
        .9
      ));
      if(pill.active){
        const pH = (Math.sin(ts*.005)+1)/2;
        glow(pill.x,pill.y,pill.r,mix('#00aaff','#ff39ff',pH),.95);
      }

      // Tail & Frenzy Aura
      const skip = Math.max(1,Math.ceil(player.tail.length/MAX_TAIL_DRAW));
      for(let i=0; i<player.tail.length; i+=skip){
        const p = player.tail[i];
        glow(
          p.x,p.y,
          player.r*(1 - i/player.tail.length),
          mix('#00e4b8','#ff39ff',i/player.tail.length),
          .3
        );
      }
      if(frenzy){
        ctx.globalAlpha = .15;
        const g = ctx.createRadialGradient(
          player.x,player.y,player.r*.8,
          player.x,player.y,player.r*8
        );
        g.addColorStop(0,'#ff39ff');
        g.addColorStop(1,'transparent');
        ctx.fillStyle=g;
        ctx.beginPath();
        ctx.arc(player.x,player.y,player.r*8,0,Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      // Player Glow
      glow(
        player.x,player.y,player.r,
        player.blink>0
          ? (player.blink%200<100?'#fff':'#ff44ff')
          : '#00e4b8',
        1
      );

      // Update 3D Head
      const yawIdx   = Math.round(((player.heading%(2*Math.PI))+2*Math.PI)/(2*Math.PI)*COLS)%COLS;
      const pitchIdx = Math.round(((-Math.sin(player.heading)+1)/2)*(ROWS-1));
      updateHead(
        player.x*zoom + offset.x,
        player.y*zoom + offset.y,
        yawIdx, pitchIdx, zoom
      );

      // Particles
      particles.forEach((p,i)=>{
        p.x+=p.dx; p.y+=p.dy; p.ttl-=dt;
        glow(p.x,p.y,p.r,p.col,.6);
        if(p.ttl<=0) particles.splice(i,1);
      });

      // Radar
      if(radarActive){
        rctx.clearRect(0,0,70,70);
        rctx.strokeStyle='#666'; rctx.lineWidth=1;
        rctx.beginPath();
        rctx.moveTo(35,0); rctx.lineTo(35,70);
        rctx.moveTo(0,35); rctx.lineTo(70,35);
        rctx.stroke();
        const mc    = Math.max(C_RING_DIST,Math.abs(player.x),Math.abs(player.y))||1,
              scale = (30-RADAR_PADDING)/mc;
        const pip = (arr,col,s)=>{
          rctx.fillStyle=col;
          arr.forEach(o=>{
            const x=35+o.x*scale, y=35+o.y*scale;
            if(x<0||x>70||y<0||y>70) return;
            if(s==='d'){
              rctx.beginPath();
              rctx.moveTo(x,y-2);
              rctx.lineTo(x+2,y);
              rctx.lineTo(x,y+2);
              rctx.lineTo(x-2,y);
              rctx.fill();
            } else if(s==='t'){
              rctx.beginPath();
              rctx.moveTo(x,y-2);
              rctx.lineTo(x+2,y+2);
              rctx.lineTo(x-2,y+2);
              rctx.fill();
            } else {
              rctx.fillRect(x-2,y-2,4,4);
            }
          });
        };
        pip([player],'#00e4b8');
        pip(titans,  '#cc00ff','d');
        pip(spectres,'#ff39ff','t');
        pip(reapers, '#ff8800');
      }

      // HUD update
      massEl.textContent  = player.mass.toFixed(0);
      scoreEl.textContent = Math.floor(player.mass*10);
      levelEl.textContent = level;

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // iOS audio unlock
    addEventListener('pointerdown', ()=>{
      const bg = document.getElementById('backgroundMusic');
      if(bg && bg.paused) bg.play().catch(()=>{});
    }, { once:true });
  </script>
</body>
</html>